# Quickstart

In this guide you will create a basic App that can echo to received messages.

---

## 1. Creating an App

First, create an app in Team Management if you donâ€™t have one yet.  
[Create app](../manage-apps/TM-create-app.md)

## 2. Include the SDK into your project

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

<Tabs>
<TabItem value="gradle" label="Gradle">

```kotlin
dependencies {
    implementation("com.wire:wire-apps-jvm-sdk:0.0.1")
}
```

</TabItem>
<TabItem value="maven" label="Maven">

```xml
<dependency>
    <groupId>com.wire</groupId>
    <artifactId>wire-apps-jvm-sdk</artifactId>
    <version>0.0.1</version>
</dependency>
```

</TabItem>
</Tabs>

## 3. Initiate the SDK

### Handling Events

The SDK uses the `WireEventsHandler` to notify your application about events and messages. Override the methods that you need in this class to handle them however you want. The http connection, deserialization, authentication and decrypting are performed by the Application, so you will receive the event as a `WireMessage`

Here's a complete example showing how to initialize the SDK and handle received events:

<Tabs groupId="programming-language">
<TabItem value="kotlin" label="Kotlin">

```kotlin
fun main() {
    val wireAppSdk = WireAppSdk(
        applicationId = UUID.fromString("YOUR_APPLICATION_ID"),
        apiToken = "YOUR_API_TOKEN",
        apiHost = "YOUR_API_HOST",
        cryptographyStoragePassword = "YOUR_32_CHAR_STORAGE_PASSWORD",
        object : WireEventsHandlerSuspending() {
            override suspend fun onMessage(wireMessage: WireMessage.Text) {
                println("Message received: $wireMessage")

                // Add your message handling logic here, like storing the message,
                //   sending back another message, or triggering some workflow
            }
        }
    )

    // Start the SDK
    wireAppSdk.startListening()
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
public class Main {
    public static void main(String[] args) {
        final var wireAppSdk = new WireAppSdk(
            UUID.fromString("YOUR_APPLICATION_ID"),
            "YOUR_API_TOKEN",
            "YOUR_API_HOST",
            "YOUR_32_CHAR_STORAGE_PASSWORD",
            new WireEventsHandlerDefault() {
                @Override
                public void onMessage(@NotNull WireMessage.Text wireMessage) {
                    System.out.println("Message received: $wireMessage");

                    // Add your message handling logic here, like storing the message,
                    //   sending back another message, or triggering some workflow
                }
            }
        );

        // Start the SDK
        wireAppSdk.startListening();
    }
}
```

</TabItem>
</Tabs>
For simplicity the subclassing of WireEventsHandler is done inline as an anonymous class, but you can create a separate class for it,
especially if you handle events in a complex way:

<Tabs groupId="programming-language">
<TabItem value="kotlin" label="Kotlin">

```kotlin
class MyWireEventsHandler : WireEventsHandlerSuspending() {
    private val logger = LoggerFactory.getLogger(MyWireEventsHandler::class.java)

    override suspend fun onMessage(wireMessage: WireMessage.Text) {
        logger.info("Message received: $wireMessage")
    }
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
public class MyWireEventsHandler extends WireEventsHandlerDefault {
    private static final Logger logger = LoggerFactory.getLogger(MyWireEventsHandler.class);

    @Override
    public void onMessage(@NotNull WireMessage.Text wireMessage) {
        logger.info("Message received: $wireMessage");
    }
}

```

</TabItem>
</Tabs>
## 4. Echoing a received message

In your `onMessage` implementation from `MyWireEventsHandler` you can echo a message as:

<Tabs groupId="programming-language">
<TabItem value="kotlin" label="Kotlin">

```kotlin
override suspend fun onMessage(wireMessage: WireMessage.Text) {
    val message = WireMessage.Text.createReply(
        conversationId = wireMessage.conversationId,
        text = "${wireMessage.text} -- Sent from the SDK",
        mentions = wireMessage.mentions,
        originalMessage = wireMessage
    )

    // The manager is accessible through the inherited WireEventsHandler class.
    // It is used to manage the Wire application's lifecycle and communication with the backend.
    manager.sendMessageSuspending(message = message)
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
@Override
public void onMessage(@NotNull WireMessage.Text wireMessage) {
    final WireMessage reply = WireMessage.Text.createReply(
            wireMessage.conversationId(),
            wireMessage.text() + " -- Sent from the SDK",
            wireMessage.mentions(),
            wireMessage.linkPreviews(),
            wireMessage,
            null);

    // The manager is accessible through the inherited WireEventsHandler class.
    // It is used to manage the Wire application's lifecycle and communication with the backend.
    getManager().sendMessage(reply);
}
```

</TabItem>
</Tabs>
## 5. Conclusion

With this basic setup you now have a running Echo App.

You can check other events in [Wire Events](events.md)
