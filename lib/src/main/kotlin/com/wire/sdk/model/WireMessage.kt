/*
 * Wire
 * Copyright (C) 2025 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 */

package com.wire.sdk.model

import com.wire.sdk.exception.WireException
import com.wire.sdk.model.protobuf.MessageContentEncoder
import com.wire.sdk.model.protobuf.MessageEncryptionAlgorithm
import java.nio.file.Path
import java.util.UUID
import kotlin.time.Clock
import kotlin.time.Instant

@Suppress("ArrayInDataClass")
sealed interface WireMessage {
    // The message id, auto-generated by the SDK while sending, useful to later edit/delete it
    val id: UUID

    // The conversation where this message is sent/received
    val conversationId: QualifiedId

    // The user/apps that sent this message, useful when receiving messages, ignored when sending
    val sender: QualifiedId

    sealed interface Item

    sealed interface Ephemeral {
        val expiresAfterMillis: Long?
    }

    /**
     * Extra sealed interface for data classes that can be used to reply.
     */
    sealed interface Replyable {
        val timestamp: Instant
    }

    @JvmRecord
    @ConsistentCopyVisibility
    data class Text @JvmOverloads internal constructor(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        override val expiresAfterMillis: Long? = null,
        override val timestamp: Instant,
        val text: String,
        val quotedMessageId: UUID? = null,
        val quotedMessageSha256: ByteArray? = null,
        val mentions: List<Mention> = emptyList(),
        val linkPreviews: List<LinkPreview> = emptyList()
    ) : WireMessage,
        Item,
        Ephemeral,
        Replyable {
        companion object {
            /**
             * Creates a basic text message with minimal required parameters.
             *
             * @param conversationId The qualified ID of the conversation
             * @param text The text content of the message
             * @param mentions List of [Mention] included in the text
             * @param linkPreviews List of [LinkPreview] to be displayed
             * @param expiresAfterMillis The time in milliseconds for an ephemeral message
             * @return A new Text message with a random UUID
             */
            @JvmStatic
            fun create(
                conversationId: QualifiedId,
                text: String,
                mentions: List<Mention> = emptyList(),
                linkPreviews: List<LinkPreview> = emptyList(),
                expiresAfterMillis: Long? = null
            ): Text =
                Text(
                    id = UUID.randomUUID(),
                    conversationId = conversationId,
                    sender = QualifiedId(
                        id = UUID.randomUUID(),
                        domain = UUID.randomUUID().toString()
                    ),
                    text = text,
                    mentions = mentions,
                    linkPreviews = linkPreviews,
                    timestamp = Clock.System.now(),
                    expiresAfterMillis = expiresAfterMillis
                )

            /**
             * Creates a reply message with minimal parameters.
             *
             * @param conversationId The qualified ID of the conversation
             * @param text The text content of the message
             * @param mentions List of [Mention] included in the text
             * @param linkPreviews List of [LinkPreview] to be displayed
             * @param originalMessage The Original message a reply will be set on.
             *  Note: it only accepts WireMessage that extends [Replyable]
             * @param expiresAfterMillis The time in milliseconds for an ephemeral message
             * @return A new Text message with a random UUID
             */
            @JvmStatic
            @Suppress("LongParameterList")
            fun createReply(
                conversationId: QualifiedId,
                text: String,
                mentions: List<Mention> = emptyList(),
                linkPreviews: List<LinkPreview> = emptyList(),
                originalMessage: WireMessage,
                expiresAfterMillis: Long? = null
            ): Text {
                require(originalMessage is Replyable) {
                    "Unsupported replied WireMessage: ${originalMessage::class.simpleName}"
                }

                return Text(
                    id = UUID.randomUUID(),
                    conversationId = conversationId,
                    sender = QualifiedId(
                        id = UUID.randomUUID(),
                        domain = UUID.randomUUID().toString()
                    ),
                    text = text,
                    mentions = mentions,
                    quotedMessageId = originalMessage.id,
                    quotedMessageSha256 = MessageContentEncoder.encodeMessageContent(
                        message = originalMessage
                    )?.sha256Digest,
                    linkPreviews = linkPreviews,
                    timestamp = Clock.System.now(),
                    expiresAfterMillis = expiresAfterMillis
                )
            }
        }
    }

    @JvmRecord
    data class Mention @JvmOverloads constructor(
        val userId: QualifiedId,
        val offset: Int = 0,
        val length: Int = 0
    )

    @JvmRecord
    data class LinkPreview @JvmOverloads constructor(
        val url: String,
        val urlOffset: Int,
        val permanentUrl: String? = null,
        val title: String? = null,
        val summary: String? = null,
        val image: LinkPreviewAsset? = null
    ) {
        @JvmRecord
        data class LinkPreviewAsset @JvmOverloads constructor(
            val name: String? = null,
            val mimeType: String,
            val metadata: Asset.AssetMetadata? = null,
            val assetDataPath: Path?,
            val assetDataSize: Long,
            val assetHeight: Int,
            val assetWidth: Int,
            val assetName: String? = null,
            val assetKey: String? = null,
            val assetToken: String? = null,
            val assetDomain: String? = null,
            val otrKey: ByteArray = ByteArray(0),
            val sha256Key: ByteArray = ByteArray(0),
            val encryptionAlgorithm: MessageEncryptionAlgorithm =
                MessageEncryptionAlgorithm.AES_CBC
        )
    }

    @JvmRecord
    data class Asset @JvmOverloads constructor(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        override val expiresAfterMillis: Long? = null,
        override val timestamp: Instant = Clock.System.now(),
        val sizeInBytes: Long,
        val name: String? = null,
        val mimeType: String,
        val metadata: AssetMetadata? = null,
        val remoteData: RemoteData? = null
    ) : WireMessage,
        Ephemeral,
        Replyable {
        sealed class AssetMetadata {
            data class Image(
                val width: Int,
                val height: Int
            ) : AssetMetadata()

            data class Video(
                val width: Int?,
                val height: Int?,
                val durationMs: Long?
            ) : AssetMetadata()

            data class Audio(
                val durationMs: Long?,
                val normalizedLoudness: ByteArray?
            ) : AssetMetadata()
        }

        @JvmRecord
        data class RemoteData @JvmOverloads constructor(
            val otrKey: ByteArray,
            val sha256: ByteArray,
            val assetId: String,
            val assetToken: String? = null,
            val assetDomain: String,
            val encryptionAlgorithm: MessageEncryptionAlgorithm? = null
        )

        companion object {
            private val SUPPORTED_IMAGE_ASSET_MIME_TYPES =
                setOf("image/jpg", "image/jpeg", "image/png", "image/gif", "image/webp")
            private val SUPPORTED_AUDIO_ASSET_MIME_TYPES = setOf(
                "audio/mp3",
                "audio/mp4",
                "audio/mpeg",
                "audio/ogg",
                "audio/wav",
                "audio/x-wav",
                "audio/x-pn-wav",
                "audio/x-m4a"
            )
            private val SUPPORTED_VIDEO_ASSET_MIME_TYPES =
                setOf("video/mp4", "video/webm", "video/3gpp", "video/mkv")

            fun isImageMimeType(mimeType: String): Boolean =
                mimeType in SUPPORTED_IMAGE_ASSET_MIME_TYPES

            fun isAudioMimeType(mimeType: String): Boolean =
                mimeType in SUPPORTED_AUDIO_ASSET_MIME_TYPES

            fun isVideoMimeType(mimeType: String): Boolean =
                mimeType in SUPPORTED_VIDEO_ASSET_MIME_TYPES
        }
    }

    @JvmRecord
    data class Button @JvmOverloads constructor(
        val text: String,
        val id: String = UUID.randomUUID().toString()
    ) : Item

    @JvmRecord
    data class Composite(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        val items: List<Item>
    ) : WireMessage {
        companion object {
            /**
             * Creates a Composite message with a single text first, followed by a list of buttons.
             *
             * @param conversationId The qualified ID of the conversation
             * @param text The text content of the message
             * @param buttonList The list of buttons to be selected
             * @return A new Composite message
             */
            @JvmStatic
            fun create(
                conversationId: QualifiedId,
                text: String,
                buttonList: List<Button>
            ): Composite {
                val textItem = Text.create(
                    conversationId = conversationId,
                    text = text
                )

                return Composite(
                    id = UUID.randomUUID(),
                    conversationId = conversationId,
                    sender = QualifiedId(
                        id = UUID.randomUUID(),
                        domain = UUID.randomUUID().toString()
                    ),
                    items = listOf(textItem) + buttonList
                )
            }
        }
    }

    /**
     * Notifies the author of a [Composite] message that a user has
     * selected one of its buttons.
     * @see Composite
     * @see ButtonActionConfirmation
     */
    @JvmRecord
    data class ButtonAction(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        /**
         * The ID of the original composite message.
         */
        val referencedMessageId: String,
        /**
         * ID of the button that was selected.
         */
        val buttonId: String
    ) : WireMessage

    /**
     * Message sent by the author of a [Composite] to
     * notify which button should be marked as selected.
     * For example, after we send [ButtonAction], the author might reply
     * with [ButtonActionConfirmation] to confirm that the button event was processed.
     * @see ButtonAction
     * @see Composite
     */
    @JvmRecord
    data class ButtonActionConfirmation(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        /**
         * ID fo the original composite message
         */
        val referencedMessageId: String,
        /**
         * ID of the selected button. Null if no button should be marked as selected.
         */
        val buttonId: String?
    ) : WireMessage {
        companion object {
            @JvmStatic
            fun create(
                conversationId: QualifiedId,
                referencedMessageId: String,
                buttonId: String?
            ) = ButtonActionConfirmation(
                id = UUID.randomUUID(),
                conversationId = conversationId,
                sender = QualifiedId(
                    id = UUID.randomUUID(),
                    domain = UUID.randomUUID().toString()
                ),
                referencedMessageId = referencedMessageId,
                buttonId = buttonId
            )
        }
    }

    @JvmRecord
    @ConsistentCopyVisibility
    data class Ping @JvmOverloads internal constructor(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        override val expiresAfterMillis: Long? = null
    ) : WireMessage,
        Ephemeral {
        companion object {
            /**
             * Creates a basic Ping message with minimal required parameters.
             *
             * @param conversationId The qualified ID of the conversation
             * @param expiresAfterMillis The time in milliseconds for an ephemeral message
             * @return A new Ping message with a random UUID
             */
            @JvmStatic
            fun create(
                conversationId: QualifiedId,
                expiresAfterMillis: Long? = null
            ) = Ping(
                id = UUID.randomUUID(),
                conversationId = conversationId,
                sender = QualifiedId(
                    id = UUID.randomUUID(),
                    domain = UUID.randomUUID().toString()
                ),
                expiresAfterMillis = expiresAfterMillis
            )
        }
    }

    @JvmRecord
    @ConsistentCopyVisibility
    data class Location @JvmOverloads internal constructor(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        override val expiresAfterMillis: Long? = null,
        override val timestamp: Instant,
        val latitude: Float,
        val longitude: Float,
        val name: String? = null,
        val zoom: Int = 0
    ) : WireMessage,
        Ephemeral,
        Replyable {
        companion object {
            /**
             * Creates a basic Location message with minimal required parameters.
             *
             * @param conversationId The qualified ID of the conversation
             * @param latitude The Latitude of the Location
             * @param longitude The Longitude of the Location
             * @param name In case the location contains a name
             * @param zoom The zoom value to be used when displaying the location on a map
             * @param expiresAfterMillis The time in milliseconds for an ephemeral message
             * @return A new Location message with a random UUID
             */
            @Suppress("LongParameterList")
            @JvmStatic
            fun create(
                conversationId: QualifiedId,
                latitude: Float,
                longitude: Float,
                name: String? = null,
                zoom: Int = 0,
                timestamp: Instant = Clock.System.now(),
                expiresAfterMillis: Long? = null
            ) = Location(
                id = UUID.randomUUID(),
                conversationId = conversationId,
                sender = QualifiedId(
                    id = UUID.randomUUID(),
                    domain = UUID.randomUUID().toString()
                ),
                latitude = latitude,
                longitude = longitude,
                name = name,
                zoom = zoom,
                timestamp = timestamp,
                expiresAfterMillis = expiresAfterMillis
            )
        }
    }

    @JvmRecord
    data class Deleted(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        val messageId: UUID
    ) : WireMessage {
        companion object {
            /**
             * Creates a basic Deleted message (a message was deleted).
             *
             * @param conversationId The qualified ID of the conversation
             * @param messageId The ID of the deleted message
             * @return A new Deleted message with a random UUID
             */
            @JvmStatic
            fun create(
                conversationId: QualifiedId,
                messageId: UUID
            ): Deleted =
                Deleted(
                    id = UUID.randomUUID(),
                    conversationId = conversationId,
                    sender = QualifiedId(
                        id = UUID.randomUUID(),
                        domain = UUID.randomUUID().toString()
                    ),
                    messageId = messageId
                )
        }
    }

    @JvmRecord
    data class Receipt(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        val type: Type,
        val messageIds: List<String>
    ) : WireMessage {
        enum class Type {
            DELIVERED,
            READ
        }

        companion object {
            /**
             * Creates a basic Receipt message.
             *
             * @param conversationId The qualified ID of the conversation
             * @param type The type of receipt (DELIVERED or READ)
             * @param messages The related message IDs
             * @return A new Receipt message with a random UUID
             */
            @JvmStatic
            fun create(
                conversationId: QualifiedId,
                type: Type,
                messages: List<String> = emptyList()
            ): Receipt =
                Receipt(
                    id = UUID.randomUUID(),
                    conversationId = conversationId,
                    sender = QualifiedId(
                        id = UUID.randomUUID(),
                        domain = UUID.randomUUID().toString()
                    ),
                    type = type,
                    messageIds = messages
                )
        }
    }

    @JvmRecord
    @ConsistentCopyVisibility
    data class TextEdited @JvmOverloads internal constructor(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        val replacingMessageId: UUID,
        val newContent: String,
        val newLinkPreviews: List<LinkPreview> = emptyList(),
        val newMentions: List<Mention> = emptyList()
    ) : WireMessage {
        companion object {
            /**
             * Creates a TextEdited message with minimal required parameters.
             *
             * @param replacingMessageId The UUID of the original message to be edited.
             * @param conversationId The qualified ID of the conversation
             * @param text The text content of the message
             * @param mentions List of [Mention] included in the text
             * @return A new TextEdited message with the original received ID.
             */
            @JvmStatic
            fun create(
                replacingMessageId: UUID,
                conversationId: QualifiedId,
                text: String,
                mentions: List<Mention> = emptyList()
            ) = TextEdited(
                id = UUID.randomUUID(),
                replacingMessageId = replacingMessageId,
                conversationId = conversationId,
                sender = QualifiedId(
                    id = UUID.randomUUID(),
                    domain = UUID.randomUUID().toString()
                ),
                newContent = text,
                newMentions = mentions
            )
        }
    }

    @JvmRecord
    data class CompositeEdited(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        val replacingMessageId: UUID,
        val newItems: List<Item>
    ) : WireMessage {
        companion object {
            @JvmStatic
            fun create(
                replacingMessageId: UUID,
                conversationId: QualifiedId,
                text: String,
                buttonList: List<Button>
            ): CompositeEdited {
                val textItem = Text.create(
                    conversationId = conversationId,
                    text = text
                )

                return CompositeEdited(
                    id = UUID.randomUUID(),
                    conversationId = conversationId,
                    sender = QualifiedId(
                        id = UUID.randomUUID(),
                        domain = UUID.randomUUID().toString()
                    ),
                    replacingMessageId = replacingMessageId,
                    newItems = listOf(textItem) + buttonList
                )
            }
        }
    }

    @JvmRecord
    data class Reaction(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        val messageId: String,
        val emojiSet: Set<String>
    ) : WireMessage {
        companion object {
            /**
             * Creates a Reaction message with minimal required parameters.
             *
             * @param conversationId The qualified ID of the conversation
             * @param messageId The ID of the message that will receive the Reaction
             * @param emojiSet A Set<String> of emojis to be sent
             * @return A new TextEdited message with the original received ID.
             */
            @JvmStatic
            fun create(
                conversationId: QualifiedId,
                messageId: String,
                emojiSet: Set<String> = emptySet()
            ) = Reaction(
                id = UUID.randomUUID(),
                conversationId = conversationId,
                sender = QualifiedId(
                    id = UUID.randomUUID(),
                    domain = UUID.randomUUID().toString()
                ),
                messageId = messageId,
                emojiSet = emojiSet
            )
        }
    }

    @JvmRecord
    data class InCallEmoji(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        val emojis: Map<String, Int>
    ) : WireMessage

    @JvmRecord
    data class InCallHandRaise(
        override val id: UUID,
        override val conversationId: QualifiedId,
        override val sender: QualifiedId,
        val isHandUp: Boolean
    ) : WireMessage

    data object Ignored : WireMessage {
        override val id: UUID
            get() = throw WireException.InvalidParameter("Ignored message, no ID")
        override val conversationId: QualifiedId
            get() = throw WireException.InvalidParameter("Ignored message, no conversation")
        override val sender: QualifiedId
            get() = throw WireException.InvalidParameter("Ignored message, no sender")
    }

    data object Unknown : WireMessage {
        override val id: UUID
            get() = throw WireException.InvalidParameter("Unknown message, no ID")
        override val conversationId: QualifiedId
            get() = throw WireException.InvalidParameter("Unknown message, no conversation")
        override val sender: QualifiedId
            get() = throw WireException.InvalidParameter("Unknown message, no sender")
    }
}
